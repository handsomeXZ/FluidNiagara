// Copyright HandsomeCheese. All Rights Reserved.
#include "/Plugin/FDOverlayEditor/Private/FDMathUtils.usf"

struct FCurveKey
{
    float Time;
    float Value;
    float ArriveTangent;
    float LeaveTangent;
};

float FloatBezierInterp(float P0, float P1, float P2, float P3, float Alpha)
{
	const float P01 = lerp(P0, P1, Alpha);
    const float P12 = lerp(P1, P2, Alpha);
    const float P23 = lerp(P2, P3, Alpha);
    const float P012 = lerp(P01, P12, Alpha);
    const float P123 = lerp(P12, P23, Alpha);
    const float P0123 = lerp(P012, P123, Alpha);

	return P0123;
}

float EvalForTwoKeyBuffer(const FCurveKey Key1, const FCurveKey Key2, const float InTime)
{
	const float Diff = Key2.Time - Key1.Time;

	if (Diff > 0.f)
	{
		const float Alpha = (InTime - Key1.Time) / Diff;
		const float P0 = Key1.Value;
		const float P3 = Key2.Value;

		const float OneThird = 1.0f / 3.0f;
		const float P1 = P0 + (Key1.LeaveTangent * Diff * OneThird);
		const float P2 = P3 - (Key2.ArriveTangent * Diff * OneThird);

		return FloatBezierInterp(P0, P1, P2, P3, Alpha);
	}
	else
	{
		return Key1.Value;
	}
}

float Eval(StructuredBuffer<FCurveKey> KeyBuffer, uint StartIndex, uint NumKeyBufferIn, float TimeIn)
{
    uint NumKeyBuffer = NumKeyBufferIn;

    float InterpVal = 0;

    if (NumKeyBuffer == 0)
    {
		// If no KeyBuffer in curve, return the Default value. 
    }
    else if (NumKeyBuffer < 2 || (TimeIn <= KeyBuffer[StartIndex].Time))
    {
        if (NumKeyBuffer > 1)
        {
            float DT = KeyBuffer[StartIndex + 1].Time - KeyBuffer[StartIndex].Time;

            if (IsNearlyZero(DT))
            {
                InterpVal = KeyBuffer[StartIndex].Value;
            }
            else
            {
                float DV = KeyBuffer[StartIndex + 1].Value - KeyBuffer[StartIndex].Value;
                float Slope = DV / DT;

                InterpVal = Slope * (TimeIn - KeyBuffer[StartIndex].Time) + KeyBuffer[StartIndex].Value;
            }
        }
        else
        {
			// Otherwise if constant or in a cycle or oscillate, always use the first key value
            InterpVal = KeyBuffer[StartIndex].Value;
        }
    }
    else if (TimeIn < KeyBuffer[StartIndex + NumKeyBuffer - 1].Time)
    {
		// perform a lower bound to get the second of the interpolation nodes
        int first = StartIndex + 1;
        int last = StartIndex + NumKeyBuffer - 1;
        int count = last - first;

        while (count > 0)
        {
            int step = count / 2;
            int middle = first + step;

            if (TimeIn >= KeyBuffer[middle].Time)
            {
                first = middle + 1;
                count -= step + 1;
            }
            else
            {
                count = step;
            }
        }

        InterpVal = EvalForTwoKeyBuffer(KeyBuffer[first - 1], KeyBuffer[first], TimeIn);
    }
    else
    {
        float DT = KeyBuffer[StartIndex + NumKeyBuffer - 2].Time - KeyBuffer[StartIndex + NumKeyBuffer - 1].Time;

        if (IsNearlyZero(DT))
        {
            InterpVal = KeyBuffer[StartIndex + NumKeyBuffer - 1].Value;
        }
        else
        {
            float DV = KeyBuffer[StartIndex + NumKeyBuffer - 2].Value - KeyBuffer[StartIndex + NumKeyBuffer - 1].Value;
            float Slope = DV / DT;

            InterpVal = Slope * (TimeIn - KeyBuffer[StartIndex + NumKeyBuffer - 1].Time) + KeyBuffer[StartIndex + NumKeyBuffer - 1].Value;
        }
    }

    return InterpVal;
}
