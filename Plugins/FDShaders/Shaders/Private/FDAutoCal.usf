#include "/Plugin/FDOverlayEditor/Private/BezierUtils.usf"

struct FCurveKey
{
	float Time;
	float Value;
	float ArriveTangent;
	float LeaveTangent;
};
struct FAppliedVertex
{
	float3 Position;
	float3 Normal;
	float2 UV;
};
struct FTriangle
{
	int A;
	int B;
	int C;
};
struct FParams
{
	int2 Size;
    float3 GradientOrigin;
    float3 GradientDir;
    float GradientMax;
    float3 UVCurveOrigin;
    float MaxCurveOffset; // It is not the maximum value, but the maximum length. For example, the maximum length between -1 and 1 is 2
};
StructuredBuffer<FAppliedVertex> VerticesBuffer  	: register(t0);
StructuredBuffer<FTriangle> TrianglesBuffer  	: register(t1);
StructuredBuffer<FCurveKey> KeyBuffer : register(t2);
StructuredBuffer<FParams> ParamsBuffer  	: register(t3);
RWTexture2D<float4> RWOutput : register(u0);



float DistancePointToLine(float3 p, float3 o, float3 dir)
{
    float3 v = p - o;
    float d = length(cross(v, dir));
    return d / length(dir);
}

float DistancePointAlongLine(float3 p, float3 o, float3 dir)
{
    float3 v = p - o;
    float d = length(dot(v, dir));
    return d / length(dir);
}

float3 PointAtLine(float3 p, float3 o, float3 dir)
{
    float len = DistancePointAlongLine(p, o, dir);
    return dir * len + o;
}

// Barycentric coordinates
bool IsPointInsideTriangle(float2 P, float2 A, float2 B, float2 C)
{
    float u = ((B.y - C.y) * (P.x - C.x) + (C.x - B.x) * (P.y - C.y)) / ((B.y - C.y) * (A.x - C.x) + (C.x - B.x) * (A.y - C.y));
    float v = ((C.y - A.y) * (P.x - C.x) + (A.x - C.x) * (P.y - C.y)) / ((B.y - C.y) * (A.x - C.x) + (C.x - B.x) * (A.y - C.y));
    float w = 1.0f - u - v;
    return (u >= 0.0f) && (v >= 0.0f) && (w >= 0.0f) && (u <= 1.0f) && (v <= 1.0f) && (w <= 1.0f);
}

float3 GetPixelPos(float2 Pixeluv, float2 Auv, float2 Buv, float3 A, float3 B, float3 C)
{
    float3 w = normalize(cross(A - B, C - B));
    float3 u = normalize(float3(B - A));
    float3 v = cross(u, w);
    
    float4x4 ToWorld = float4x4(u.x, u.y, u.z, 0,
                                v.z, v.y, v.z, 0,
                                w.x, w.y, w.z, 0,
                                A.x, A.y, A.z, 1);
    // 需要判断 pixel 在 AB向量的哪一侧
    float isLeft = normalize(cross(float3(Pixeluv - Auv, 0), float3(Buv - Auv, 0))) / w;
    float Pu = dot(Pixeluv - Auv, Buv - Auv) / length(Buv - Auv);
    float Pv = DistancePointToLine(float3(Pixeluv, 0), float3(Auv, 0), float3(Buv - Auv, 0)) * isLeft;
    float4 PixelLocal = float4(Pu, Pv, 0, 1);
    return mul(PixelLocal, ToWorld).xzy;
}

[numthreads(THREADGROUPSIZE_X, THREADGROUPSIZE_Y, 1)]
void CS(
	uint3 GroupId : SV_GroupID,
	uint3 GroupThreadId : SV_GroupThreadID,
	uint3 DispatchThreadId : SV_DispatchThreadID)
{
    int KeyNum = 0, VertexNum = 0, TriangleNum = 0;
    int KeySize = 0, VertexSize = 0, TriangleSize = 0;
    float3 GradientDir = normalize(ParamsBuffer[0].GradientDir);
    float3 GradientOrigin = ParamsBuffer[0].GradientOrigin;
    
    float2 UV = (float2)1 / float2(DispatchThreadId.x, DispatchThreadId.y);
    VerticesBuffer.GetDimensions(VertexNum, VertexSize);
    TrianglesBuffer.GetDimensions(TriangleNum, TriangleSize);
    KeyBuffer.GetDimensions(KeyNum, KeySize);
    RWOutput[DispatchThreadId.xy] = 0;
    for (int tri = 0; tri < TriangleNum; tri++)
    {
        if (IsPointInsideTriangle(UV, VerticesBuffer[TrianglesBuffer[tri].A].UV, VerticesBuffer[TrianglesBuffer[tri].B].UV, VerticesBuffer[TrianglesBuffer[tri].C].UV))
        {
            RWOutput[DispatchThreadId.xy].w = 1;
            float3 PixelPos = GetPixelPos(UV, VerticesBuffer[TrianglesBuffer[tri].A].UV, VerticesBuffer[TrianglesBuffer[tri].B].UV, VerticesBuffer[TrianglesBuffer[tri].A].Position, VerticesBuffer[TrianglesBuffer[tri].B].Position, VerticesBuffer[TrianglesBuffer[tri].C].Position);
            
            float GradientScale = DistancePointAlongLine(PixelPos, GradientOrigin, GradientDir) / ParamsBuffer[0].GradientMax;
            // Draw UV - V
            if (GradientScale >= 0)
            {
                RWOutput[DispatchThreadId.xy].y = GradientScale;
            }
            // Draw UV - U
            double AngleOffset = Eval(GradientScale);
            float3 UVCurvePoint = PointAtLine(PixelPos, ParamsBuffer[0].UVCurveOrigin, GradientDir);
            float3 PixAtLinePoint = PointAtLine(PixelPos, GradientOrigin, GradientDir);
            float3 A = UVCurvePoint - PixAtLinePoint;
            float3 B = PixelPos - PixAtLinePoint;
            float AngleScale = degrees(acos(dot(A, B) / (length(A) * length(B)))) / 360.0 + (normalize(cross(A, B)) / GradientDir + 1) * 90; // Since the dot can only calculate angles of 180 degrees at most, additional calculations are added to ensure that the result is 0 to 360
            // if > 0, AngleOffset = AngleOffset; 
            // if < 0, -40 => 320, -370 => 710;
            AngleOffset = floor(abs(AngleOffset)) + fmod(AngleOffset, 360.0) + (abs(AngleOffset) / AngleOffset * -1 + 1) * 180;
            AngleScale += AngleOffset;
            RWOutput[DispatchThreadId.xy].x = AngleScale / ParamsBuffer[0].MaxCurveOffset;
            break;
        }

    }

    

}