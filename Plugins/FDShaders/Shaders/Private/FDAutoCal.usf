#include "/Engine/Public/Platform.ush"
#include "/Plugin/FDShaders/Private/BezierUtils.usf"

struct FAppliedVertex
{
    float3 Position;
    float3 Normal;
    float2 UV;
};
struct FTriangle
{
    int A;
    int B;
    int C;
    int MID;
};
struct FParams
{
    float3 GradientOrigin;
    float3 GradientDir;
    float GradientMax;
    float3 UVCurveOrigin;
    float CurveRange; // It is not the maximum value, but the maximum length. For example, the maximum length between -1 and 1 is 2
    int KeyNum;
    int VertexNum;
    int TriangleNum;
};
StructuredBuffer<FAppliedVertex> VerticesBuffer  	: register(t0);
StructuredBuffer<FTriangle> TrianglesBuffer  	: register(t1);
StructuredBuffer<FCurveKey> KeyBuffer : register(t2);
StructuredBuffer<FParams> ParamsBuffer  	: register(t3);
RWTexture2DArray<float4> RDGRWTexture : register(u0);

[numthreads(THREADGROUPSIZE_X, THREADGROUPSIZE_Y, 1)]
void CS(
	uint3 GroupId : SV_GroupID,
	uint3 GroupThreadId : SV_GroupThreadID,
	uint3 DispatchThreadId : SV_DispatchThreadID)
{
    float3 GradientDir = normalize(ParamsBuffer[0].GradientDir);
    float3 GradientOrigin = ParamsBuffer[0].GradientOrigin;
    float2 UVScale;
    uint MNum;
    RDGRWTexture.GetDimensions(UVScale.x, UVScale.y, MNum);
    
    float2 UV = float2(DispatchThreadId.x, DispatchThreadId.y) / UVScale;
    
    for (int Mid = 0; Mid < MNum; Mid++)
    {
        RDGRWTexture[uint3(DispatchThreadId.xy, Mid)] = 0;
    }
    for (int tri = 0; tri < ParamsBuffer[0].TriangleNum; tri++)
    {
        
        if (IsPointInsideTriangle(UV, VerticesBuffer[TrianglesBuffer[tri].A].UV, VerticesBuffer[TrianglesBuffer[tri].B].UV, VerticesBuffer[TrianglesBuffer[tri].C].UV))
        {
            float3 PixelPos = GetPixelPos(UV, VerticesBuffer[TrianglesBuffer[tri].A].UV, VerticesBuffer[TrianglesBuffer[tri].B].UV, VerticesBuffer[TrianglesBuffer[tri].C].UV,
            VerticesBuffer[TrianglesBuffer[tri].A].Position, VerticesBuffer[TrianglesBuffer[tri].B].Position, VerticesBuffer[TrianglesBuffer[tri].C].Position, 100);
            
            float GradientScale = DistancePointAlongLine(PixelPos, GradientOrigin, GradientDir) / ParamsBuffer[0].GradientMax;
            
            if (GradientScale >= 0)
            {
            // Draw UV - V
                RDGRWTexture[uint3(DispatchThreadId.xy, TrianglesBuffer[tri].MID)].y = saturate(GradientScale);
            
            // Draw UV - U
                float AngleOffset = Eval(KeyBuffer, 0, ParamsBuffer[0].KeyNum, GradientScale);
                float3 UVCurvePoint = PointAtLine(PixelPos, ParamsBuffer[0].UVCurveOrigin, GradientDir);
                float3 PixAtLinePoint = PointAtLine(PixelPos, GradientOrigin, GradientDir);
                float3 A = UVCurvePoint - PixAtLinePoint;
                float3 B = PixelPos - PixAtLinePoint;
                float AngleScale = degrees(acos(dot(normalize(A), normalize(B))));
                AngleScale = dot(normalize(cross(A, B)), GradientDir) * (180 * length((normalize(cross(A, B)) + GradientDir)) - AngleScale); // Since the dot can only calculate angles of 180 degrees at most, additional calculations are added to ensure that the result is 0 to 360
            // if > 0, AngleOffset = AngleOffset; 
            // if < 0, -40 => 320, -370 => 710, -500 => 580;
            // AngleOffset = 30, same layer: 10 => 40, 350 => 20
            // AngleOffset = -30, same layer: 10 => 340, 350 => 320
            // Step 1
                AngleOffset = floor(abs(AngleOffset - fmod(AngleOffset, 360.0))) + fmod(AngleOffset, 360.0) + IsNegative(AngleOffset) * 360;
            // Step 2
                AngleScale = fmod(AngleOffset + AngleScale + IsNegative(AngleOffset + AngleScale) * 360, 360.0);
            
                RDGRWTexture[uint3(DispatchThreadId.xy, TrianglesBuffer[tri].MID)].x = AngleScale / 360.0;
                RDGRWTexture[uint3(DispatchThreadId.xy, TrianglesBuffer[tri].MID)].w = 1;
            }
        }
        
    }
    

}