#include "/Engine/Public/Platform.ush"
#include "/Plugin/FDShaders/Private/BezierUtils.usf"

struct FAppliedVertex
{
    float3 Position;
    float3 Normal;
    float2 UV;
};
struct FTriangle
{
    int A;
    int B;
    int C;
};
struct FParams
{
    float3 GradientOrigin;
    float3 GradientDir;
    float GradientMax;
    float3 UVCurveOrigin;
    float CurveRange; // It is not the maximum value, but the maximum length. For example, the maximum length between -1 and 1 is 2
    
};
StructuredBuffer<FAppliedVertex> VerticesBuffer  	: register(t0);
StructuredBuffer<FTriangle> TrianglesBuffer  	: register(t1);
StructuredBuffer<FCurveKey> KeyBuffer : register(t2);
StructuredBuffer<FParams> ParamsBuffer  	: register(t3);
RWTexture2D<float4> RDGRWTexture : register(u0);



float DistancePointToLine(float3 p, float3 o, float3 dir)
{
    dir = normalize(dir);
    float3 v = p - o;
    float d = length(cross(v, dir));
    //return d / length(dir);
    return d;
}

float DistancePointAlongLine(float3 p, float3 o, float3 dir)
{
    dir = normalize(dir);
    float3 v = p - o;
    float d = length(dot(v, dir));
    //return d / length(dir);
    return d;
}

float3 PointAtLine(float3 p, float3 o, float3 dir)
{
    float len = DistancePointAlongLine(p, o, dir);
    return dir * len + o;
}

// Barycentric coordinates
bool IsPointInsideTriangle(float2 P, float2 A, float2 B, float2 C)
{
    float u = ((B.y - C.y) * (P.x - C.x) + (C.x - B.x) * (P.y - C.y)) / ((B.y - C.y) * (A.x - C.x) + (C.x - B.x) * (A.y - C.y));
    float v = ((C.y - A.y) * (P.x - C.x) + (A.x - C.x) * (P.y - C.y)) / ((B.y - C.y) * (A.x - C.x) + (C.x - B.x) * (A.y - C.y));
    float w = 1.0f - u - v;
    return (u >= 0.0f) && (v >= 0.0f) && (w >= 0.0f) && (u <= 1.0f) && (v <= 1.0f) && (w <= 1.0f);
}

float3 GetPixelPos(float2 Pixeluv, float2 Auv, float2 Buv, float3 A, float3 B, float3 C)
{
    float3 w = normalize(cross(A - B, C - B));
    float3 u = normalize(float3(B - A));
    float3 v = cross(u, w);
    
    float4x4 ToWorld = float4x4(u.x, u.y, u.z, 0,
                                v.z, v.y, v.z, 0,
                                w.x, w.y, w.z, 0,
                                A.x, A.y, A.z, 1);
    // 需要判断 pixel 在 AB向量的哪一侧
    float isLeft = normalize(cross(float3(Pixeluv - Auv, 0), float3(Buv - Auv, 0))) / w;
    float Pu = dot(Pixeluv - Auv, Buv - Auv) / length(Buv - Auv);
    float Pv = DistancePointToLine(float3(Pixeluv, 0), float3(Auv, 0), float3(Buv - Auv, 0)) * isLeft;
    float4 PixelLocal = float4(Pu, Pv, 0, 1);
    return mul(PixelLocal, ToWorld).xzy;
}


float Eval(float InTime)
{
    uint NumKeyBuffer = 0;
    uint CurveKeySize = 0;
    KeyBuffer.GetDimensions(NumKeyBuffer, CurveKeySize);

    float InterpVal = 0;

    if (NumKeyBuffer == 0)
    {
		// If no KeyBuffer in curve, return the Default value.
    }
    else if (NumKeyBuffer < 2 || (InTime <= KeyBuffer[0].Time))
    {
        if (NumKeyBuffer > 1)
        {
            float DT = KeyBuffer[1].Time - KeyBuffer[0].Time;

            if (IsNearlyZero(DT))
            {
                InterpVal = KeyBuffer[0].Value;
            }
            else
            {
                float DV = KeyBuffer[1].Value - KeyBuffer[0].Value;
                float Slope = DV / DT;

                InterpVal = Slope * (InTime - KeyBuffer[0].Time) + KeyBuffer[0].Value;
            }
        }
        else
        {
			// Otherwise if constant or in a cycle or oscillate, always use the first key value
            InterpVal = KeyBuffer[0].Value;
        }
    }
    else if (InTime < KeyBuffer[NumKeyBuffer - 1].Time)
    {
		// perform a lower bound to get the second of the interpolation nodes
        int first = 1;
        int last = NumKeyBuffer - 1;
        int count = last - first;

        while (count > 0)
        {
            int step = count / 2;
            int middle = first + step;

            if (InTime >= KeyBuffer[middle].Time)
            {
                first = middle + 1;
                count -= step + 1;
            }
            else
            {
                count = step;
            }
        }

        InterpVal = EvalForTwoKeyBuffer(KeyBuffer[first - 1], KeyBuffer[first], InTime);
    }
    else
    {
        float DT = KeyBuffer[NumKeyBuffer - 2].Time - KeyBuffer[NumKeyBuffer - 1].Time;

        if (IsNearlyZero(DT))
        {
            InterpVal = KeyBuffer[NumKeyBuffer - 1].Value;
        }
        else
        {
            float DV = KeyBuffer[NumKeyBuffer - 2].Value - KeyBuffer[NumKeyBuffer - 1].Value;
            float Slope = DV / DT;

            InterpVal = Slope * (InTime - KeyBuffer[NumKeyBuffer - 1].Time) + KeyBuffer[NumKeyBuffer - 1].Value;
        }
    }

    return InterpVal;
}

[numthreads(THREADGROUPSIZE_X, THREADGROUPSIZE_Y, 1)]
void CS(
	uint3 GroupId : SV_GroupID,
	uint3 GroupThreadId : SV_GroupThreadID,
	uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint KeyNum = 0, VertexNum = 0, TriangleNum = 0;
    uint KeySize = 0, VertexSize = 0, TriangleSize = 0;
    float3 GradientDir = normalize(ParamsBuffer[0].GradientDir);
    float3 GradientOrigin = ParamsBuffer[0].GradientOrigin;
    
    float2 UV = (float2)1 / float2(DispatchThreadId.x, DispatchThreadId.y);
    VerticesBuffer.GetDimensions(VertexNum, VertexSize);
    TrianglesBuffer.GetDimensions(TriangleNum, TriangleSize);
    KeyBuffer.GetDimensions(KeyNum, KeySize);
    RDGRWTexture[DispatchThreadId.xy] = 1;
    for (int tri = 0; tri < TriangleNum; tri++)
    {
        if (IsPointInsideTriangle(UV, VerticesBuffer[TrianglesBuffer[tri].A].UV, VerticesBuffer[TrianglesBuffer[tri].B].UV, VerticesBuffer[TrianglesBuffer[tri].C].UV))
        {
            RDGRWTexture[DispatchThreadId.xy].w = 1;
            float3 PixelPos = GetPixelPos(UV, VerticesBuffer[TrianglesBuffer[tri].A].UV, VerticesBuffer[TrianglesBuffer[tri].B].UV, VerticesBuffer[TrianglesBuffer[tri].A].Position, VerticesBuffer[TrianglesBuffer[tri].B].Position, VerticesBuffer[TrianglesBuffer[tri].C].Position);
            
            float GradientScale = DistancePointAlongLine(PixelPos, GradientOrigin, GradientDir) / ParamsBuffer[0].GradientMax;
            // Draw UV - V
            if (GradientScale >= 0)
            {
                RDGRWTexture[DispatchThreadId.xy].y = GradientScale;
            }
            // Draw UV - U
            double AngleOffset = Eval(GradientScale);
            float3 UVCurvePoint = PointAtLine(PixelPos, ParamsBuffer[0].UVCurveOrigin, GradientDir);
            float3 PixAtLinePoint = PointAtLine(PixelPos, GradientOrigin, GradientDir);
            float3 A = UVCurvePoint - PixAtLinePoint;
            float3 B = PixelPos - PixAtLinePoint;
            float AngleScale = degrees(acos(dot(A, B) / (length(A) * length(B)))) / 360.0 + (normalize(cross(A, B)) / GradientDir + 1) * 90; // Since the dot can only calculate angles of 180 degrees at most, additional calculations are added to ensure that the result is 0 to 360
            // if > 0, AngleOffset = AngleOffset; 
            // if < 0, -40 => 320, -370 => 710;
            AngleOffset = floor(abs(AngleOffset)) + fmod(AngleOffset, 360.0) + (abs(AngleOffset) / AngleOffset * -1 + 1) * 180;
            AngleScale += AngleOffset;
            RDGRWTexture[DispatchThreadId.xy].x = AngleScale / ParamsBuffer[0].CurveRange;
            break;
        }

    }

    

}