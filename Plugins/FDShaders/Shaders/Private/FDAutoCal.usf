#include "/Engine/Public/Platform.ush"
#include "/Plugin/FDShaders/Private/BezierUtils.usf"

struct FAppliedVertex
{
    float3 Position;
    float3 Normal;
    float2 UV;
};
struct FTriangle
{
    int A;
    int B;
    int C;
    int MID;
};
struct FParams
{
    float3 GradientOrigin;
    float3 GradientDir;
    float GradientMax;
    float3 UVCurveOrigin;
    float CurveRange; // It is not the maximum value, but the maximum length. For example, the maximum length between -1 and 1 is 2
    int KeyNum;
    int VertexNum;
    int TriangleNum;
};
StructuredBuffer<FAppliedVertex> VerticesBuffer  	: register(t0);
StructuredBuffer<FTriangle> TrianglesBuffer  	: register(t1);
StructuredBuffer<FCurveKey> KeyBuffer : register(t2);
StructuredBuffer<FParams> ParamsBuffer  	: register(t3);
RWTexture2DArray<float4> RDGRWTexture : register(u0);

// Negative: 1
// Positive: 0
float IsNegative(float valueIn)
{
    return 1 - saturate(ceil(valueIn));
}

float DistancePointToLine(float3 p, float3 o, float3 dir)
{
    dir = normalize(dir);
    float3 v = p - o;
    float d = cross(v, dir);
    //return d / length(dir);
    return d;
}

float DistancePointAlongLine(float3 p, float3 o, float3 dir)
{
    dir = normalize(dir);
    float3 v = p - o;
    float d = dot(v, dir);
    //return d / length(dir);
    return d;
}

float3 PointAtLine(float3 p, float3 o, float3 dir)
{
    float len = DistancePointAlongLine(p, o, dir);
    return normalize(dir) * len + o;
}

// Barycentric coordinates
bool IsPointInsideTriangle(float2 P, float2 A, float2 B, float2 C)
{
    float u = ((B.y - C.y) * (P.x - C.x) + (C.x - B.x) * (P.y - C.y)) / ((B.y - C.y) * (A.x - C.x) + (C.x - B.x) * (A.y - C.y));
    float v = ((C.y - A.y) * (P.x - C.x) + (A.x - C.x) * (P.y - C.y)) / ((B.y - C.y) * (A.x - C.x) + (C.x - B.x) * (A.y - C.y));
    float w = 1.0f - u - v;
    return (u >= 0.0f) && (v >= 0.0f) && (w >= 0.0f) && (u <= 1.0f) && (v <= 1.0f) && (w <= 1.0f);
}

float3 GetPixelPos(float2 Pixeluv, float2 Auv, float2 Buv, float2 Cuv, float3 A, float3 B, float3 C, float2 UVScale)
{
    Pixeluv = Pixeluv * UVScale;
    Auv = Auv * UVScale;
    Buv = Buv * UVScale;
    Cuv = Cuv * UVScale;
    float3 w = normalize(cross(B - A, C - A));
    float3 v = normalize(float3(B - A));
    float3 u = cross(v, w);
    
    float4x4 ToWorld = float4x4(u.x, u.y, u.z, 0,
                                v.x, v.y, v.z, 0,
                                w.x, w.y, w.z, 0,
                                A.x, A.y, A.z, 1);
    // 需要判断 pixel 在 AB向量的哪一侧
    //float isLeft =  length(normalize(cross(float3(Pixeluv - Auv, 0), float3(Buv - Auv, 0))) + w) - 1;
    float Pv = dot(Pixeluv - Auv, normalize(Buv - Auv));
    float3 uvNormal = cross(normalize(float3(Buv, 0) - float3(Auv, 0)), normalize(float3(Cuv, 0) - float3(Auv, 0)));
    float Pu = dot(float3(Pixeluv - Auv, 0), normalize(cross(normalize(float3(Buv, 0) - float3(Auv, 0)), normalize(uvNormal))));
    //DistancePointToLine(float3(Pixeluv, 0), float3(Auv, 0), float3(Buv - Auv, 0)) * isLeft;
    float4 PixelLocal = float4(Pu, Pv, 0, 1);
    return mul(PixelLocal, ToWorld).xyz;
}


float Eval(float InTime)
{
    uint NumKeyBuffer = ParamsBuffer[0].KeyNum;

    float InterpVal = 0;

    if (NumKeyBuffer == 0)
    {
		// If no KeyBuffer in curve, return the Default value. 
    }
    else if (NumKeyBuffer < 2 || (InTime <= KeyBuffer[0].Time))
    {
        if (NumKeyBuffer > 1)
        {
            float DT = KeyBuffer[1].Time - KeyBuffer[0].Time;

            if (IsNearlyZero(DT))
            {
                InterpVal = KeyBuffer[0].Value;
            }
            else
            {
                float DV = KeyBuffer[1].Value - KeyBuffer[0].Value;
                float Slope = DV / DT;

                InterpVal = Slope * (InTime - KeyBuffer[0].Time) + KeyBuffer[0].Value;
            }
        }
        else
        {
			// Otherwise if constant or in a cycle or oscillate, always use the first key value
            InterpVal = KeyBuffer[0].Value;
        }
    }
    else if (InTime < KeyBuffer[NumKeyBuffer - 1].Time)
    {
		// perform a lower bound to get the second of the interpolation nodes
        int first = 1;
        int last = NumKeyBuffer - 1;
        int count = last - first;

        while (count > 0)
        {
            int step = count / 2;
            int middle = first + step;

            if (InTime >= KeyBuffer[middle].Time)
            {
                first = middle + 1;
                count -= step + 1;
            }
            else
            {
                count = step;
            }
        }

        InterpVal = EvalForTwoKeyBuffer(KeyBuffer[first - 1], KeyBuffer[first], InTime);
    }
    else
    {
        float DT = KeyBuffer[NumKeyBuffer - 2].Time - KeyBuffer[NumKeyBuffer - 1].Time;

        if (IsNearlyZero(DT))
        {
            InterpVal = KeyBuffer[NumKeyBuffer - 1].Value;
        }
        else
        {
            float DV = KeyBuffer[NumKeyBuffer - 2].Value - KeyBuffer[NumKeyBuffer - 1].Value;
            float Slope = DV / DT;

            InterpVal = Slope * (InTime - KeyBuffer[NumKeyBuffer - 1].Time) + KeyBuffer[NumKeyBuffer - 1].Value;
        }
    }

    return InterpVal;
}

[numthreads(THREADGROUPSIZE_X, THREADGROUPSIZE_Y, 1)]
void CS(
	uint3 GroupId : SV_GroupID,
	uint3 GroupThreadId : SV_GroupThreadID,
	uint3 DispatchThreadId : SV_DispatchThreadID)
{
    float3 GradientDir = normalize(ParamsBuffer[0].GradientDir);
    float3 GradientOrigin = ParamsBuffer[0].GradientOrigin;
    float2 UVScale;
    uint MNum;
    RDGRWTexture.GetDimensions(UVScale.x, UVScale.y, MNum);
    
    float2 UV = float2(DispatchThreadId.x, DispatchThreadId.y) / UVScale;
    
    for (int Mid = 0; Mid < MNum; Mid++)
    {
        RDGRWTexture[uint3(DispatchThreadId.xy, Mid)] = 0;
    }
    for (int tri = 0; tri < ParamsBuffer[0].TriangleNum; tri++)
    {
        
        if (IsPointInsideTriangle(UV, VerticesBuffer[TrianglesBuffer[tri].A].UV, VerticesBuffer[TrianglesBuffer[tri].B].UV, VerticesBuffer[TrianglesBuffer[tri].C].UV))
        {
            RDGRWTexture[uint3(DispatchThreadId.xy, TrianglesBuffer[tri].MID)].w = 1;
            float3 PixelPos = GetPixelPos(UV, VerticesBuffer[TrianglesBuffer[tri].A].UV, VerticesBuffer[TrianglesBuffer[tri].B].UV, VerticesBuffer[TrianglesBuffer[tri].C].UV, 
            VerticesBuffer[TrianglesBuffer[tri].A].Position, VerticesBuffer[TrianglesBuffer[tri].B].Position, VerticesBuffer[TrianglesBuffer[tri].C].Position, 100);
            
            float GradientScale = DistancePointAlongLine(PixelPos, GradientOrigin, GradientDir) / ParamsBuffer[0].GradientMax;
            
            // Draw UV - V
            RDGRWTexture[uint3(DispatchThreadId.xy, TrianglesBuffer[tri].MID)].y = saturate(GradientScale);
            
            // Draw UV - U
            float AngleOffset = Eval(GradientScale);    
            float3 UVCurvePoint = PointAtLine(PixelPos, ParamsBuffer[0].UVCurveOrigin, GradientDir);
            float3 PixAtLinePoint = PointAtLine(PixelPos, GradientOrigin, GradientDir);
            float3 A = UVCurvePoint - PixAtLinePoint;
            float3 B = PixelPos - PixAtLinePoint;
            float AngleScale = degrees(acos(dot(normalize(A), normalize(B)))); 
            AngleScale = dot(normalize(cross(A, B)), GradientDir) * (180 * length((normalize(cross(A, B)) + GradientDir)) - AngleScale); // Since the dot can only calculate angles of 180 degrees at most, additional calculations are added to ensure that the result is 0 to 360
            // if > 0, AngleOffset = AngleOffset; 
            // if < 0, -40 => 320, -370 => 710, -500 => 580;
            // AngleOffset = 30, same layer: 10 => 40, 350 => 20
            // AngleOffset = -30, same layer: 10 => 340, 350 => 320
            // Step 1
            AngleOffset = floor(abs(AngleOffset - fmod(AngleOffset, 360.0))) + fmod(AngleOffset, 360.0) + IsNegative(AngleOffset) * 360;
            // Step 2
            AngleScale = fmod(AngleOffset + AngleScale + IsNegative(AngleOffset + AngleScale) * 360, 360.0);
            
            RDGRWTexture[uint3(DispatchThreadId.xy, TrianglesBuffer[tri].MID)].x = AngleScale / 360.0;

        }
        
    }
    

}