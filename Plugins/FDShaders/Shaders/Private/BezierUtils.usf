struct FCurveKey
{
    float Time;
    float Value;
    float ArriveTangent;
    float LeaveTangent;
};

bool IsNearlyZero(float Value)
{
    return abs(Value) < 0.000001;
}
float FloatBezierInterp(float P0, float P1, float P2, float P3, float Alpha)
{
	const float P01 = lerp(P0, P1, Alpha);
    const float P12 = lerp(P1, P2, Alpha);
    const float P23 = lerp(P2, P3, Alpha);
    const float P012 = lerp(P01, P12, Alpha);
    const float P123 = lerp(P12, P23, Alpha);
    const float P0123 = lerp(P012, P123, Alpha);

	return P0123;
}

float EvalForTwoKeyBuffer(const FCurveKey Key1, const FCurveKey Key2, const float InTime)
{
	const float Diff = Key2.Time - Key1.Time;

	if (Diff > 0.f)
	{
		const float Alpha = (InTime - Key1.Time) / Diff;
		const float P0 = Key1.Value;
		const float P3 = Key2.Value;

		const float OneThird = 1.0f / 3.0f;
		const float P1 = P0 + (Key1.LeaveTangent * Diff * OneThird);
		const float P2 = P3 - (Key2.ArriveTangent * Diff * OneThird);

		return FloatBezierInterp(P0, P1, P2, P3, Alpha);
	}
	else
	{
		return Key1.Value;
	}
}
