

bool void IsNearlyZero(float Value)
{
	return abs(value) < 0.000001;
}
float FloatBezierInterp(float P0, float P1, float P2, float P3, float Alpha)
{
	const float P01 = FMath::Lerp(P0, P1, Alpha);
	const float P12 = FMath::Lerp(P1, P2, Alpha);
	const float P23 = FMath::Lerp(P2, P3, Alpha);
	const float P012 = FMath::Lerp(P01, P12, Alpha);
	const float P123 = FMath::Lerp(P12, P23, Alpha);
	const float P0123 = FMath::Lerp(P012, P123, Alpha);

	return P0123;
}

float EvalForTwoKeys(const FRichCurveKey& Key1, const FRichCurveKey& Key2, const float InTime)
{
	const float Diff = Key2.Time - Key1.Time;

	if (Diff > 0.f)
	{
		const float Alpha = (InTime - Key1.Time) / Diff;
		const float P0 = Key1.Value;
		const float P3 = Key2.Value;

		const float OneThird = 1.0f / 3.0f;
		const float P1 = P0 + (Key1.LeaveTangent * Diff * OneThird);
		const float P2 = P3 - (Key2.ArriveTangent * Diff * OneThird);

		return FloatBezierInterp(P0, P1, P2, P3, Alpha);
	}
	else
	{
		return Key1.Value;
	}
}

float Eval(float InTime) const
{

	const int32 NumKeys = Keys.Num();

	float InterpVal = 0;

	if (NumKeys == 0)
	{
		// If no keys in curve, return the Default value.
	}
	else if (NumKeys < 2 || (InTime <= Keys[0].Time))
	{
		if (NumKeys > 1)
		{
			float DT = Keys[1].Time - Keys[0].Time;

			if (IsNearlyZero(DT))
			{
				InterpVal = Keys[0].Value;
			}
			else
			{
				float DV = Keys[1].Value - Keys[0].Value;
				float Slope = DV / DT;

				InterpVal = Slope * (InTime - Keys[0].Time) + Keys[0].Value;
			}
		}
		else
		{
			// Otherwise if constant or in a cycle or oscillate, always use the first key value
			InterpVal = Keys[0].Value;
		}
	}
	else if (InTime < Keys[NumKeys - 1].Time)
	{
		// perform a lower bound to get the second of the interpolation nodes
		int32 first = 1;
		int32 last = NumKeys - 1;
		int32 count = last - first;

		while (count > 0)
		{
			int32 step = count / 2;
			int32 middle = first + step;

			if (InTime >= Keys[middle].Time)
			{
				first = middle + 1;
				count -= step + 1;
			}
			else
			{
				count = step;
			}
		}

		InterpVal = EvalForTwoKeys(Keys[first - 1], Keys[first], InTime);
	}
	else
	{
		float DT = Keys[NumKeys - 2].Time - Keys[NumKeys - 1].Time;

		if (IsNearlyZero(DT))
		{
			InterpVal = Keys[NumKeys - 1].Value;
		}
		else
		{
			float DV = Keys[NumKeys - 2].Value - Keys[NumKeys - 1].Value;
			float Slope = DV / DT;

			InterpVal = Slope * (InTime - Keys[NumKeys - 1].Time) + Keys[NumKeys - 1].Value;
		}
	}

	return InterpVal;
}